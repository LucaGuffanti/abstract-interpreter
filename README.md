# Implementations

All exercise points have been completed.

## First, Simple interpreter

The first implementation is a simple interpreter that reads the program and performs static analysis by simulating the execution 
(without supports to while loops) of the program. The interpreter is implemented in the file `interpreter.cpp`, and associates an interval to every variable, representing the upper and lower bounds of possible values that said variable can assume.
The implementation is rather simple: statements are parsed and a syntactic tree is built. The interpreter traverses the tree and updates the intervals of the variables according to the statements. Statements are mapped onto commands that update the intervals by evaluating the expressions. The interpreter is able to handle the following statements:

- Assignment
- If-else

When post-conditions are met they are evaluated and the program continues, eventually raising a warning if the postcondition is not satisfied. If division by zero or possible overflows are encountered, the interpreter warns the user.

## Second, Equational interpreter

The second implementation is an equational interpreter that performs static analysis in four phases.

1. The AST describing the code is generated by parsing the code provided as input.
2. The AST is traversed to generate a set of locations and equation that describe the program.
3. The analysis is executed through a fixpoint iteration that continues until convergence.
4. Postconditions are finally evaluated.

It's implemented in `equational_interpreter.cpp`. The notable difference between the first implementation is the presence of locations and the use of a fixpoint, which implies that the analysis is not directly performed by simulating the execution of the program. Instead, we construct a set of locations that are associated to commands that be executed on the respective invariants. Commands are implemented with `std::function` functional objects, and are constructed based on the type of statement, as expressed by the equational semantics.

When all locations are constructed, the fixpoint is iterated. For every step of the fixpoint we first perform a deep copy of the complete state of the interpreter, we update the state by executing the commands (remembering information from the previous iteration), and then check if the fixpoint has been reached by comparing the current state with the previous one. If the fixpoint is reached, the analysis is stopped and the postconditions are evaluated.

# How do I run it

Executing the interpreter can be done by simply running the main executable (`absint`) from the `build` folder that you construct by compiling the code, passing the path to the file 
as a command line parameter. Based on the implementation, we have different levels of verbosity. The first implementation is less verbose
because of its simplicity. The second implementation is, instead, more verbose, and prints more information about the analysis.